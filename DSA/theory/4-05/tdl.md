> How much DS is required?
familiarity with basic data structures like stack, queue, linked list, hash maps, etc should be known.
- Arrays 
- linked lists 
- strings 
Stacks, queue, lists, trees, graphs and sorting techniques are very important and will be asked by all major IT companies.

1. Day  −∞  to 0: Stick to a programming language like C or C++. Make sure that you are comfortable with pointers/objects.

2. Day 1: Understand the concept of Algorithmic complexity. Skip the theory for now, but for every piece of code you write, you should be able to derive both time and space complexity.

3. Day 2 - 10: Let’s start with some simple data structures,
Arrays
Linked Lists
Strings
Stacks
Queues
Understand their basic operations (insert, delete, search, traversal) and their complexity - Big-O Algorithm Complexity Cheat Sheet, and code them all.

3. Day 11 - 25: Let’s now learn some simple algorithms,

4. Sorting - Insertion sort, Merge sort, Quick sort, Heap sort, Bucket sort, Counting sort, Radix sort, External sorting
Search - Linear search, Binary Search (along with its variants).
Prime Numbers - Sieve of Eratosthenes, Primality test
Strings - String searching, LCS, Palindrome detection
Miscellaneous - Euclidean algorithm, Matrix multiplication, Fibonacci Numbers, Pascal's Triangle, Max Subarray problem

5. Day 26 - 50: Once you are comfortable with everything above, start doing problems from,

Cracking the Coding Interview
Elements of Programming Interviews
Programming Interviews Exposed: Secrets to Landing Your Next Job
GeeksforGeeks
HackerRank
InterviewBit
Stick to chapters of arrays, linked lists, strings, stacks, queues and complexity.

6. Day 51 - 60: Let’s learn some non-linear data structures,
- Tree
- Binary Tree, Binary Search Tree - Tree traversals, Lowest common ancestor, Depth, Height & Diameter, Finding k-th smallest element
- Heaps
- Hash table - 4 sum problem, Checking if sudoku solution is valid
- Graph - Breadth-first search, Depth-first search, Topological sorting, Minimum spanning tree, Shortest path problem,

7. Day 61- 90: Refer to the previous resources and start doing problems from trees, hash tables, heaps and graphs.

8. Day 91 - 100: Understand Computational complexity theory and NP-completeness, Knapsack problem, Travelling salesman problem, SAT problem and so on.

9. Day 101 -  ∞ : You are now better than most of the CS undergrads. Keep revising the above topics and start competitive programming! Good luck!

How you approach the problem is more important than being able to solve it 
Try to break problem into chunks

10. got myself used to some basic CS fundamentals like Computer Networks, OS and DBMS and this took up two more months . So it came up to November.

11. Keep up with tech trends:
-  blockchain development 
- join newsletter - thehustle.co 
- online groups 

Learn about the different parts of the stack—scalability, front end, mobile, etc. Learn about security. Internationalization. Design. Computer architecture.

While you're at it, learn how to be a good employee. Get comfortable with public speaking. Learn how to write well, which means clear, concisely and professionally (not elegant creative prose).

Learn DS & A (and Math) because they are fun tools which can help solve interesting problems. Problems which are also very rewarding when solved. Problems which exist outside the big companies too. 

You could also try reading about algorithms or taking algorithms classes on Coursera. This should help you write time- and space-efficient code.

- Data structures: Array, Linked List, Stack, Queue, Hash Table, BST, Map (Hash vs Tree), Set, Trie, Graph.
- Algorithms: Time complexity, Space complexity, Recursion, Sorting, Searching, BFS & DFS, Dynamic programming, Bit manipulations


